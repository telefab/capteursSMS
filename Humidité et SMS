// Modifier Buffer Arduino : dans un terminal entrer la commande : sudo gedit /usr/share/arduino/libraries/SoftwareSerial/SoftwareSerial.h
// Modifier la valeur de MAX_RX_BUFFER à 256

#include <FreqCounter.h> // 
#include <Wire.h>
#include <SoftwareSerial.h>

#define SEUIL_BAS 10
#define SEUIL_HAUT 30
#define TEMPS_ATTENTE 30                // En secondes
#define TEMPS_ATTENTE_SECURITE 6        // En secondes

// Variables capteurs
int freq,sens,offset ;
float humiditeCapteur1= (SEUIL_BAS + SEUIL_HAUT) /2;
boolean intervalleCapteur1=true;

// Variables relatives au shield GPRS
SoftwareSerial GSM(7,8);           // GSM : relatif au shield GPRS ; Serial : relatif à l'ordinateur
int ledGSM = 13;
int onModulePin = 9;                // the pin to switch on the module (without press on button)
String phone_number="+33647877083"; // ********* is the number to call



int i2cRead2bytes(int deviceaddress, byte address) {
 // SET ADDRESS
 Wire.beginTransmission(deviceaddress);
 Wire.write(address); 
 Wire.endTransmission();
 // REQUEST RETURN VALUE
 Wire.requestFrom(deviceaddress, 2);
 // COLLECT RETURN VALUE
 int rv = 0;
 for (int c = 0; c < 2; c++ )
 if (Wire.available()) rv = rv * 256 + Wire.read();
 return rv;
 }

void switchGSMModule()
{
    digitalWrite(onModulePin,HIGH);
    delay(2100);
    digitalWrite(onModulePin,LOW);
}

boolean envoyerUnMessage(float humidite, boolean intervalle)      // "intervalle" sert a différencier si est rentré ou sorti de l'intervalle de température
{
  switchGSMModule();                              // switches the GSM module ON
  delay(500);
  GSM.print("AT+CPIN=\"0000\"\r\n");           // Entrer le code PIN
  Serial.print("AT+CPIN=\"0000\"\r\n");        // Affichage réponse sur ordinateur 
  while (!GSM.available());
  while (GSM.available())
  {
    Serial.write(GSM.read());
  }
  delay(20000);                               // Attente de l'établissement du réseau
  while (!GSM.available());
  while (GSM.available()) 
  {
    Serial.write(GSM.read());
  }
  
  GSM.print("AT+CMGF=1\r\n");                 // sets the SMS mode to text
  while (!GSM.available());
  while (GSM.available()) 
  {
    Serial.write(GSM.read());
  }
  delay(1600);

  GSM.print("AT+CMGS=\"");                     // send the SMS number
  GSM.print(phone_number);
  GSM.print("\"\r\n");
  while(GSM.read()!='>');  

  if (!intervalle)                             // SMS body, deux possibilités
  {               
    GSM.print("Attention, le seuil critique d'humidite ");
    GSM.print("dans le capteur 1 a ete atteint. L'humidite");
    GSM.print(" est de ");
  } 
  else 
  {
    GSM.print("L'humidite relative est de nouveau acceptable. Elle est de ");
  }
  GSM.print(humidite, 2); // Fin SMS body

  delay(500);
  GSM.write(0x1A);                         // Sends ++
  GSM.write(0x0D);
  GSM.write(0x0A);
  while (!GSM.available());
  while (GSM.available()) 
  {
    Serial.write(GSM.read());
  }
  
  delay(20000);
  while (!GSM.available());
  while (GSM.available()) 
  {
    Serial.write(GSM.read());
  }
  switchGSMModule();                      // Switch OFF module GSM
  return true;
}


void setup()
{
    // Setup Capteurs
    Wire.begin();
    Serial.begin(9600);
    sens   =  i2cRead2bytes(81, 10); // Lit la sensibilité de l'EEPROM (mémoire qui contient les facteurs d'étalonnage) via I2C
    offset =  i2cRead2bytes(81, 12); // Lit l'offset de l'EEPROM

    // Setup GSM
    GSM.begin(19200);                                      // UART baud GSM rate
    delay(100);
    pinMode(ledGSM, OUTPUT);
    pinMode(onModulePin, OUTPUT);
}

void loop ()
{
    sens   =  i2cRead2bytes(81, 10); 
    offset =  i2cRead2bytes(81, 12); 
    //Pour obtenir la fréquence de sortie
    FreqCounter::f_comp= 8;             // Set compensation to 12 ??
    FreqCounter::start(1000);            // Gate Time de  1000ms
    while (FreqCounter::f_ready == 0)         // Attendre que le compteur soit prêt 
    freq=FreqCounter::f_freq;            // Lire le résultat
    //Calcul de humiditeCapteur1 (humidité relative)
    humiditeCapteur1 =  (offset-freq)*sens/4096; // Calcul de l'humidité relative selon la formule donnée par le datasheet du capteur
    Serial.println(humiditeCapteur1);

    if (intervalleCapteur1 & ((humiditeCapteur1 < SEUIL_BAS) | (humiditeCapteur1 > SEUIL_HAUT)))      // On sort de l'intervalle acceptable 
    {
        delay (TEMPS_ATTENTE_SECURITE*1000);                                                                                      // Attente de 6s
        FreqCounter::f_comp= 8;             // Set compensation to 12 ??
        FreqCounter::start(1000);            // Gate Time de  1000ms
        while (FreqCounter::f_ready == 0)         // Attendre que le compteur soit prêt 
        freq=FreqCounter::f_freq;            // Lire le résultat
        //Calcul de humiditeCapteur1 (humidité relative)
        float humiditeCapteur1 =  (offset-freq)*sens/4096; // Calcul de l'humidité relative selon la formule donnée par le datasheet du capteur
        Serial.println(humiditeCapteur1);

        if ((temperatureCapteur1 < SEUIL_BAS) | (temperatureCapteur1 > SEUIL_HAUT))                         // Seconde vérification
        {
            if(envoyerUnMessage (humiditeCapteur1,false)){
            intervalleCapteur1=false;
            }
        }
    }
    else if (!intervalleCapteur1 & (humiditeCapteur1 > SEUIL_BAS) & (humiditeCapteur1 < SEUIL_HAUT))   // On rentre à nouveau dans cet intervalle
    {
        delay (TEMPS_ATTENTE_SECURITE*1000);                                                                                      // Attente de 6s
        FreqCounter::f_comp= 8;             // Set compensation to 12 ??
        FreqCounter::start(1000);            // Gate Time de  1000ms
        while (FreqCounter::f_ready == 0)         // Attendre que le compteur soit prêt 
        freq=FreqCounter::f_freq;            // Lire le résultat
        //Calcul de humiditeCapteur1 (humidité relative)
        float humiditeCapteur1 =  (offset-freq)*sens/4096; // Calcul de l'humidité relative selon la formule donnée par le datasheet du capteur
        Serial.println(humiditeCapteur1);

        if ((humiditeCapteur1 > SEUIL_BAS) & (humiditeCapteur1 < SEUIL_HAUT))                         // Seconde vérification
        {
            if(envoyerUnMessage (humiditeCapteur1,true)){
            intervalleCapteur1=true;
            }
        }
    }

    delay (TEMPS_ATTENTE*1000);                                                                                         // Attends 30s avant de recommencer
}
